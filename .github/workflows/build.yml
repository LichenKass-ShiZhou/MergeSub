name: Build linuxdeployqt and MergeSub with QT6

on:
  workflow_dispatch:
    inputs:
      build-type:
        description: '构建类型'
        required: false
        default: 'release'
        type: choice
        options:
          - release
          - debug

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write  

    steps:
      # 第一步：安装 QT6 和必要的依赖
      - name: Install QT6 and dependencies
        run: |
          sudo apt-get update
          # 添加 QT6 官方仓库（如果需要更新版本的QT6，可考虑添加）
          # sudo add-apt-repository ppa:beineri/opt-qt-6.0-xenial -y  # 根据Ubuntu版本调整
          # sudo apt-get update

          # 安装 QT6 基础开发包和其他可能需要的依赖
          sudo apt-get install -y qt6-base-dev qt6-tools-dev qt6-tools-dev-tools 
          sudo apt-get install -y libgl1-mesa-dev libxcb-xinerama0 libxkbcommon-dev
          # 查找 qmake 的路径，优先查找 qt6 版本
          QMAKE_PATH=$(which qmake6 || which qmake)  # 优先使用qmake6，其次使用qmake
          echo "QMAKE_PATH=$QMAKE_PATH" >> $GITHUB_ENV
          # 验证 qmake 版本
          $QMAKE_PATH -v

      # 第二步：克隆 linuxdeployqt 仓库并进入指定目录
      - name: Clone linuxdeployqt repository
        run: |
          git clone https://github.com/probonopd/linuxdeployqt.git
          cd linuxdeployqt/tools/linuxdeployqt
          git submodule update --init --recursive

      # 第三步：修复 main.cpp 中的语法错误
      - name: Fix main.cpp syntax errors
        run: |
          cd linuxdeployqt/tools/linuxdeployqt
          # 恢复原始文件
          git checkout -- main.cpp 
          sed -i '/if (strverscmp (glcv, "2.36") >= 0) {/,/^        }$/ s/^/\/\//' main.cpp

      # 第四步：在 CMakeLists.txt 文件中添加 CMake 最低版本要求
      - name: Add CMake minimum version requirement
        run: |
          cd linuxdeployqt/tools/linuxdeployqt
          # 在 CMakeLists.txt 文件开头添加 cmake_minimum_required(VERSION 3.31)
          if ! grep -q "cmake_minimum_required" CMakeLists.txt; then
              sed -i '1icmake_minimum_required(VERSION 3.31)' CMakeLists.txt
          fi
          
          # 添加 project() 命令
          if ! grep -q "^project(" CMakeLists.txt; then
              sed -i '/cmake_minimum_required/aproject(linuxdeployqt)' CMakeLists.txt
          fi

      # 第五步：构建 linuxdeployqt 项目 (尝试使用QT6环境，但注意linuxdeployqt可能对QT版本有特定要求)
      - name: Build linuxdeployqt project
        run: |
          cd linuxdeployqt/tools/linuxdeployqt
          # 尝试配置和构建，注意设置QT6相关的路径（如果linuxdeployqt支持）
          # 由于linuxdeployqt最初设计可能针对QT5，此处尝试使其适应QT6环境
          cmake . -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_PREFIX_PATH=/usr/lib/x86_64-linux-gnu/qt6/
          make -j$(nproc)
          make DESTDIR=appdir -j$(nproc) install
          find appdir/

      # 第六步：安装QT6和必要的依赖（包括quick和multimedia模块）
      - name: Install QT6 and dependencies (including quick and multimedia)
        run: |
          sudo apt-get update
          # 安装QT6基础开发包、quick模块、multimedia模块及其他可能需要的依赖
          sudo apt-get install -y qt6-base-dev qt6-tools-dev qt6-tools-dev-tools 
          sudo apt-get install -y qt6-declarative-dev qt6-multimedia-dev  # 明确安装缺失的模块
          sudo apt-get install -y libgl1-mesa-dev libxcb-xinerama0 libxkbcommon-dev
          # 查找qmake的路径，优先查找qt6版本
          QMAKE_PATH=$(which qmake6 || which qmake)  # 优先使用qmake6，其次使用qmake
          echo "QMAKE_PATH=$QMAKE_PATH" >> $GITHUB_ENV
          # 验证qmake版本
          $QMAKE_PATH -v
    
      # 第七步：克隆并编译 MergeSub 项目 (使用QT6)
      - name: Clone and build MergeSub with QT6
        run: |
          git clone https://github.com/LichenKass-ShiZhou/MergeSub.git
          cd MergeSub
          # 使用QT6的qmake生成Makefile
          $QMAKE_PATH MergeSub.pro
          make -j$(nproc)
          # 验证生成的二进制文件（可选）
          ls -la
          file MergeSub  # 如果生成的可执行文件名为MergeSub

      # 第八步：使用编译好的 linuxdeployqt 处理 MergeSub 以获取其依赖的共享库
      - name: Deploy MergeSub and extract shared libraries using linuxdeployqt
        run: |
          # 进入 MergeSub 构建目录
          cd MergeSub

          # 创建部署目录并复制可执行文件
          mkdir -p deploy
          cp MergeSub deploy/
          cd deploy

          # 关键：获取之前步骤中设置的 QMAKE_PATH
          QMAKE_PATH="${{ env.QMAKE_PATH }}"
          echo "Using qmake path: $QMAKE_PATH"
          
          # 提取QT安装路径（假设qmake在bin目录下）
          QT_DIR=$(dirname "$(dirname "$QMAKE_PATH")")
          echo "QT directory: $QT_DIR"
          
          # 设置必要的环境变量以确保能找到QT插件和QML模块
          export LD_LIBRARY_PATH="$QT_DIR/lib:$LD_LIBRARY_PATH"
          export QT_PLUGIN_PATH="$QT_DIR/plugins:$QT_PLUGIN_PATH"
          export QML2_IMPORT_PATH="$QT_DIR/qml:$QML2_IMPORT_PATH"
          
          # 使用编译的linuxdeployqt，并通过-qmake=参数明确指定qmake路径
          LINUX_DEPLOY_QT_PATH="../../linuxdeployqt/tools/linuxdeployqt/linuxdeployqt"
          chmod +x "$LINUX_DEPLOY_QT_PATH" # 确保可执行
          
          # 执行linuxdeployqt，使用-qmake=参数明确指定qmake路径
          # 这样可以避免"qmake not found"错误:cite[3]
          echo "Running linuxdeployqt with explicit qmake path..."
          "$LINUX_DEPLOY_QT_PATH" MergeSub -verbose=1 -qmake="$QMAKE_PATH" 2>&1 | tee linuxdeployqt.log
          
          # 检查执行结果
          LINUX_DEPLOY_EXIT_CODE=${PIPESTATUS[0]}
          if [ $LINUX_DEPLOY_EXIT_CODE -eq 0 ]; then
              echo "linuxdeployqt executed successfully!"
          else
              echo "linuxdeployqt failed with exit code $LINUX_DEPLOY_EXIT_CODE"
              echo "Check linuxdeployqt.log for details"
          fi
          
          # 检查库文件是否被收集
          echo "Contents of deployment directory:"
          ls -la .
          echo "Library directory contents (if any):"
          ls -la lib/ 2>/dev/null || echo "No lib directory found. Checking for other locations..."
          
          # 尝试使用ldd检查依赖，以验证是否所有依赖都已解决
          echo "Dependencies of MergeSub:"
          ldd MergeSub || echo "ldd command failed"
          
          # 如果linuxdeployqt失败，尝试手动复制QT库
          if [ $LINUX_DEPLOY_EXIT_CODE -ne 0 ]; then
              echo "linuxdeployqt可能失败，尝试手动复制QT库..."
              # 示例：手动创建lib目录并复制一些核心QT库（需根据实际需求调整）
              mkdir -p lib
              cp "$QT_DIR/lib/libQt6Core.so.6" lib/ 2>/dev/null || true
              cp "$QT_DIR/lib/libQt6Gui.so.6" lib/ 2>/dev/null || true
              cp "$QT_DIR/lib/libQt6Widgets.so.6" lib/ 2>/dev/null || true
              # 注意：这只是一个备选方案，可能无法覆盖所有依赖
          fi
          
          # 列出最终收集到的所有库文件
          echo "Final library collection:"
          find . -name "*.so" -o -name "*.so.*" | sort
          

      # 第九步：创建 DEB 包结构并使用 dpkg-shlibdeps 获取依赖
      - name: Create DEB package structure and determine dependencies
        run: |
          # 进入项目根目录查找 main.qml 文件
          cd $GITHUB_WORKSPACE
          
          # 查找 main.qml 文件的实际位置
          MAIN_QML_PATH=$(find . -name "main.qml" -type f | head -1)
          if [ -z "$MAIN_QML_PATH" ]; then
            VERSION="1.0.0"
            echo "Warning: main.qml not found, using default version: $VERSION"
          else
            echo "Found main.qml at: $MAIN_QML_PATH"
            # 从 main.qml 文件中提取版本号
            VERSION=$(grep -oP 'mergeSubVersion:\s*"\K[^"]+' "$MAIN_QML_PATH" | head -1)
            if [ -z "$VERSION" ]; then
              VERSION="1.0.0"
              echo "Warning: Version not found in main.qml, using default: $VERSION"
            else
              echo "Extracted version from main.qml: $VERSION"
            fi
          fi
          
          # 返回部署目录
          cd MergeSub/deploy
          
          # 创建 DEB 包的标准目录结构
          mkdir -p deb-package/DEBIAN
          mkdir -p deb-package/usr/bin
          mkdir -p deb-package/usr/lib
          mkdir -p deb-package/usr/share/applications
          
          # 复制可执行文件到 DEB 包的 bin 目录
          cp MergeSub deb-package/usr/bin/
          chmod 755 deb-package/usr/bin/MergeSub
          
          # 复制收集的库文件到 DEB 包的 lib 目录
          echo "Copying collected libraries to deb-package/usr/lib/"
          rm -rf deb-package/usr/lib/*
          if [ -d "lib" ]; then
            cp -r lib/* deb-package/usr/lib/
            echo "Libraries copied:"
            ls -la deb-package/usr/lib/
          else
            echo "Warning: lib directory not found"
          fi
          
          # 使用 echo 逐行创建桌面文件
          echo "[Desktop Entry]" > deb-package/usr/share/applications/MergeSub.desktop
          echo "Version=$VERSION" >> deb-package/usr/share/applications/MergeSub.desktop
          echo "Name=MergeSub" >> deb-package/usr/share/applications/MergeSub.desktop
          echo "GenericName=Subtitle Merger" >> deb-package/usr/share/applications/MergeSub.desktop
          echo "Comment=Tool for merging subtitles" >> deb-package/usr/share/applications/MergeSub.desktop
          echo "Exec=MergeSub" >> deb-package/usr/share/applications/MergeSub.desktop
          echo "Icon=MergeSub" >> deb-package/usr/share/applications/MergeSub.desktop
          echo "Terminal=false" >> deb-package/usr/share/applications/MergeSub.desktop
          echo "Type=Application" >> deb-package/usr/share/applications/MergeSub.desktop
          echo "Categories=Utility;" >> deb-package/usr/share/applications/MergeSub.desktop
          
          # 获取应用程序的依赖关系
          echo "Determining package dependencies..."
          cd deb-package
          
          # 创建临时 debian 目录和 control 文件以满足 dpkg-shlibdeps 的要求
          mkdir -p debian
          echo "Source: mergesub" > debian/control
          echo "Maintainer: LichenKass <yuanchengwei_sz@163.com>" >> debian/control
          
          # 使用 dpkg-shlibdeps 分析依赖
          echo "Running dpkg-shlibdeps with explicit library path..."
          dpkg-shlibdeps -O usr/bin/MergeSub --ignore-missing-info -l./usr/lib 2>../dependencies_err.log | tee ../dependencies.log
          
          # 检查 dpkg-shlibdeps 是否成功执行
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            # 提取依赖信息
            DEPENDS=$(cat ../dependencies.log | sed 's/^shlibs:Depends=//')
            echo "Detected dependencies: $DEPENDS"
          else
            echo "dpkg-shlibdeps failed, checking error log:"
            cat ../dependencies_err.log
            # 尝试使用 ldd 手动获取依赖
            echo "Falling back to ldd for dependency detection..."
            DEPENDS=$(ldd usr/bin/MergeSub | grep "=>" | awk '{print $1}' | sort -u | xargs echo | sed 's/ /, /g')
            echo "Detected dependencies (from ldd): $DEPENDS"
          fi
          
          # 使用 echo 逐行创建最终的 control 文件
          echo "Package: com.github.mergesub" > DEBIAN/control
          echo "Version: $VERSION" >> DEBIAN/control
          echo "Architecture: amd64" >> DEBIAN/control
          echo "Maintainer: LichenKass <yuanchengwei_sz@163.com>" >> DEBIAN/control
          echo "Depends: $DEPENDS" >> DEBIAN/control
          echo "Description: A tool for merging subtitles" >> DEBIAN/control
          echo " A Qt-based application for merging subtitle files." >> DEBIAN/control
          
          # 清理临时文件
          rm -rf debian
          cd ..
          
          # 显示 control 文件内容
          echo "Final control file:"
          cat deb-package/DEBIAN/control
          
          # 列出 DEB 包结构
          echo "DEB package structure:"
          find deb-package -type f -print

      - name: Login to GitHub CLI
        run: |
          # 清除可能冲突的环境变量
          unset GH_TOKEN
          # 使用 GitHub Actions 内置的 GITHUB_TOKEN
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
          # 验证认证
          gh auth status
      

      # 第十步：打包 DEB 文件并上传到 GitHub Release
      - name: Build DEB package and upload to GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 进入部署目录
          cd MergeSub/deploy
          
          # 从 control 文件中提取版本号
          VERSION="1.0.0"
          if [ -f "deb-package/DEBIAN/control" ]; then
            EXTRACTED_VERSION=$(grep 'Version:' deb-package/DEBIAN/control | awk '{print $2}')
            if [ -n "$EXTRACTED_VERSION" ]; then
              VERSION="$EXTRACTED_VERSION"
            fi
          fi
          echo "Using version: $VERSION"
          
          # 确保 deb-package 目录存在
          if [ ! -d "deb-package" ]; then
            echo "Error: deb-package directory not found!"
            exit 1
          fi
          
          # 构建 DEB 包
          echo "Building DEB package..."
          PACKAGE_NAME="com.github.mergesub_${VERSION}_amd64.deb"
          dpkg-deb -b deb-package $PACKAGE_NAME
          
          # 检查 DEB 包是否成功创建
          if [ ! -f "$PACKAGE_NAME" ]; then
            echo "Error: DEB package creation failed!"
            exit 1
          fi
          
          echo "DEB package created: $PACKAGE_NAME"
          ls -la $PACKAGE_NAME
          
          # 显示 DEB 包信息
          echo "DEB package info:"
          dpkg-deb -I $PACKAGE_NAME
          
          # 设置环境变量供后续步骤使用
          echo "DEB_PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
          echo "DEB_VERSION=$VERSION" >> $GITHUB_ENV
          
          # 创建标签（如果尚不存在）
          echo "Creating git tag v$VERSION..."
          git tag -a "v$VERSION" -m "Release version $VERSION" || echo "Tag may already exist"
          
          # 推送标签到 GitHub
          git push origin "v$VERSION" || echo "Tag push may have failed"

      # 第十一步：使用专门的 Action 创建 GitHub Release 并上传 DEB 包
      - name: Create GitHub Release and Upload DEB
        uses: softprops/action-gh-release@v1
        with:
          files: MergeSub/deploy/${{ env.DEB_PACKAGE_NAME }}
          tag_name: v${{ env.DEB_VERSION }}
          name: MergeSub v${{ env.DEB_VERSION }}
          body: |
            MergeSub subtitle tool version ${{ env.DEB_VERSION }}
            
            ### Changes
            - Automated build release
            - DEB package for Ubuntu/Debian systems
          draft: false
          prerelease: false
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
